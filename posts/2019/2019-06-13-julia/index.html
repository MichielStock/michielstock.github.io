<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <title>Uncertainty propagation and high-dimensional indexing in Julia</title> <script type="application/javascript"> var doNotTrack = false; if (!doNotTrack) { window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; ga('create', 'UA-110926897-1', 'auto'); ga('send', 'pageview'); } </script> <script async src='https://www.google-analytics.com/analytics.js'></script> <div id=layout > <div id=menu > <ul> <li><a href="/">Home</a> <li><a href="/CV/">CV</a> <li><a href="/research/">Research</a> <li><a href="/teaching/">Teaching</a> <li><a href="/blog/">Blog</a> </ul> </div> <div id=main > <div class=franklin-content > <h1 id=uncertainty_propagation_and_high-dimensional_indexing_in_julia ><a href="#uncertainty_propagation_and_high-dimensional_indexing_in_julia" class=header-anchor >Uncertainty propagation and high-dimensional indexing in Julia</a></h1> <p><img src="/images/2019_julia/julia.svg" alt="Don&#39;t at me like that python&#33; Julia just gets me&#33; It is more than a performance thing&#33;" /></p> <p>I have been playing around with the <a href="https://julialang.org">Julia language</a> for about a year now &#40;just before the stable version was released&#41;. During that year, I&#39;ve been converted from a skeptic &#40;did not catch the bug during my stay at the <a href="https://poisotlab.io/">Poisotlab</a>&#41; to an enthousiast&#33; It is not only about the speed of native Julia code, though this alone would make it worth learning, but just the general pleasure of programming in this language. The type system central to Julia is just something which clicks to me as a scientist in a way that, for example, classes never clicked with me. Here I would like to show two case studies, relevant to the scientific programmer, which I think really demonstrate how natural it is to extend Julia and write powerful, generic code.</p> <h2 id=automatic_uncertainty_propagation ><a href="#automatic_uncertainty_propagation" class=header-anchor >Automatic uncertainty propagation</a></h2> <p>During my first year of college, I really liked the physics lectures because everything was exact. In my first year of physics, I really disliked the physics labs, because everything was messy. First-year physics labs are generally disliked partially because of the uninspiring topics &#40;measuring resistance in a wire&#33; determining a heat transfer coefficient&#33; measuring chirality of sugar&#33;&#41; and partly because this was the only lab in which &#39;exact&#39; measurements had to be performed. These labs introduced the complex and unexplained rules for measurement error propagation. Without any prior statistics or probability courses, it was lost on me where these strange rules originated from, as sharp contrast to nearly everything else in physics.</p> <p>A year later, after plowing through a basic probability course, error propagation is less mysterious. Almost all these rules to account for the error can be derived from a simple principle:</p> <blockquote> <p>Given two <strong>independent</strong> random variables <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>, the variance of a linear combination <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Var</mtext><mo stretchy=false >[</mo><mi>a</mi><mi>X</mi><mo>+</mo><mi>b</mi><mi>Y</mi><mo stretchy=false >]</mo><mo>=</mo><msup><mi>a</mi><mn>2</mn></msup><mtext>Var</mtext><mo stretchy=false >[</mo><mi>X</mi><mo stretchy=false >]</mo><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup><mtext>Var</mtext><mo stretchy=false >[</mo><mi>Y</mi><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">\text{Var}[aX+bY]=a^2\text{Var}[X] + b^2\text{Var}[Y]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class=mord >Var</span></span><span class=mopen >[</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class=mclose >]</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.064108em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal">a</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord text"><span class=mord >Var</span></span><span class=mopen >[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class=mclose >]</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1.064108em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal">b</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord text"><span class=mord >Var</span></span><span class=mopen >[</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class=mclose >]</span></span></span></span>.</p> </blockquote> <p>Measurement errors are usually given by a standard deviation, the square root of the variance. Given this principle, error propagation is merely bookkeeping of the standard error on the measurement for various computations.</p> <p>Instead of processing the measurements and the standard error separately, suppose we could just make a new type of number which contains both the observed value and its uncertainty. And suppose we could just compute something with these numbers, plugging them into our formulas where the error is automatically accounted for using the standard error propagation rules. In Julia, it is dead simple to construct such new numbers and just overload existing functions such that they compute in the correct way.</p> <p>Let us make make a new type of structure <code>Measurement</code> which holds a value <code>x</code> and a &#40;positive&#41; measurement error <code>σ</code>.</p> <pre><code class="julia hljs"><span class=hljs-keyword >struct</span> Measurement
    x::<span class=hljs-built_in >Real</span>
    σ::<span class=hljs-built_in >Real</span>
    <span class=hljs-keyword >function</span> Measurement(x, σ)
        <span class=hljs-keyword >if</span> σ &lt; zero(σ)
            error(<span class=hljs-string >&quot;Measurement error should be non-zero&quot;</span>)
        <span class=hljs-keyword >end</span>
        new(x, σ)
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre> <p>We also define a function to extract the value and error from instances of the type <code>Measurement</code>. This is similar to how the real and imaginary part of a complex number are extracted. Furthermore, we modify Julia&#39;s behavior such that instances are printed as <code>x ± σ</code>.</p> <pre><code class="julia hljs">val(m::Measurement) = m.x;
err(m::Measurement) = m.σ;</code></pre> <pre><code class="julia hljs">Base.show(io::<span class=hljs-built_in >IO</span>, measurement::Measurement) = print(io, <span class=hljs-string >&quot;<span class=hljs-subst >$(measurement.x)</span> ± <span class=hljs-subst >$(measurement.σ)</span>&quot;</span>);</code></pre>
<p>An intuitive syntax is to make a new binary operator <code>±</code> that adds the measurement error to a measured value, thus creating a <code>Measurement</code> instance.</p>
<pre><code class="julia hljs">±(x, σ) = Measurement(x, σ);</code></pre>
<pre><code class="julia hljs">m = <span class=hljs-number >9.0</span> ± <span class=hljs-number >0.3</span></code></pre>
<pre><code class="julia hljs"><span class=hljs-number >9.0</span> ± <span class=hljs-number >0.3</span></code></pre>
<p>Now that we constructed the <code>Measurement</code> type, let us tell Julia how to compute with it. We can easily implement the standard <a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty#Example_formulae">uncertainty propagation rules</a>.</p>
<pre><code class="julia hljs"><span class=hljs-comment ># scalar multiplication</span>
Base.:*(a::<span class=hljs-built_in >Real</span>, m::Measurement) = a * m.x ± abs(a) * m.σ;
Base.:/(m::Measurement, a::<span class=hljs-built_in >Real</span>) = inv(a) * m;
<span class=hljs-comment ># adding and substracting measurements</span>
Base.:+(m1::Measurement, m2::Measurement) = (m1.x + m2.x) ± √(m1.σ^<span class=hljs-number >2</span> + m2.σ^<span class=hljs-number >2</span>);
Base.:-(m1::Measurement, m2::Measurement) = (m1.x - m2.x) ± √(m1.σ^<span class=hljs-number >2</span> + m2.σ^<span class=hljs-number >2</span>);
Base.:-(m::Measurement) = -m.x ± m.σ;
<span class=hljs-comment ># adding a constant</span>
Base.:+(m::Measurement, a::<span class=hljs-built_in >Real</span>) = m + (a ± zero(a));
Base.:+(a::<span class=hljs-built_in >Real</span>, m::Measurement) = m + a;
<span class=hljs-comment ># multiplying two measurments</span>
Base.:*(m1::Measurement, m2::Measurement) = m1.x * m2.x ± (m1.x * m2.x) * √((m1.σ / m1.x)^<span class=hljs-number >2</span> + (m2.σ / m2.x)^<span class=hljs-number >2</span>);</code></pre>
<p>For example:</p>
<pre><code class="julia hljs"><span class=hljs-number >2</span>m</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >18.0</span> ± <span class=hljs-number >0.6</span></code></pre>
<pre><code class="julia hljs">m + <span class=hljs-number >1.2</span></code></pre>
<pre><code class="julia hljs"><span class=hljs-number >10.2</span> ± <span class=hljs-number >0.3</span></code></pre>
<pre><code class="julia hljs">(<span class=hljs-number >12</span> ± <span class=hljs-number >0.3</span>) * (<span class=hljs-number >18</span> ± <span class=hljs-number >0.8</span>)</code></pre>
<p>216 ± 11.014535850411491</p>
<pre><code class="julia hljs">m / <span class=hljs-number >4</span></code></pre>
<p>2.25 ± 0.075</p>
<p>For nonlinear functions, we can compute an approximate uncertainty propagation using a first-order Taylor approximation. We have, for any function <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span></span></span></span>:</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo>±</mo><mi>σ</mi><mo stretchy=false >)</mo><mo>≈</mo><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo>±</mo><mi mathvariant=normal >∣</mi><msup><mi>f</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mi mathvariant=normal >∣</mi><mi>σ</mi><mtext> </mtext><mi mathvariant=normal >.</mi></mrow><annotation encoding="application/x-tex">
f(x\pm \sigma) \approx f(x) \pm |f&#x27;(x)|\sigma\,.
</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >±</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >≈</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >±</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1.051892em;vertical-align:-0.25em;"></span><span class=mord >∣</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mord >∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >.</span></span></span></span></span>
<p>For example, for squaring a function, we have</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mo stretchy=false >(</mo><mi>x</mi><mo>±</mo><mi>σ</mi><msup><mo stretchy=false >)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>±</mo><mn>2</mn><mi mathvariant=normal >∣</mi><mi>x</mi><mi mathvariant=normal >∣</mi><mi>σ</mi><mtext> </mtext><mi mathvariant=normal >.</mi></mrow><annotation encoding="application/x-tex">
(x\pm\sigma)^2 = x^2 \pm 2|x|\sigma\,.
</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >±</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class=mclose ><span class=mclose >)</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >±</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >2</span><span class=mord >∣</span><span class="mord mathnormal">x</span><span class=mord >∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >.</span></span></span></span></span>
<p>Note that this is consistent with the above rules for multiplication. Let us implement the general formula for raising a measurement to the power <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>.</p>
<pre><code class="julia hljs">Base.:^(m::Measurement, p::<span class=hljs-built_in >Integer</span>) = m.x^<span class=hljs-number >2</span> ± abs(p*m.x^(p-<span class=hljs-number >1</span>) * m.σ);</code></pre>
<pre><code class="julia hljs">m^<span class=hljs-number >2</span></code></pre>
<pre><code class="julia hljs"><span class=hljs-number >81.0</span> ± <span class=hljs-number >5.3999999999999995</span></code></pre>
<p>We can implement this for all the standard mathematical functions one by one. However, Julia provides use with two efficient tools to do this in one swoop: automatic differentiation and metaprogramming. We just loop a list of functions of interest and automatically generate the correct approximate rule.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> ForwardDiff

<span class=hljs-keyword >for</span> f <span class=hljs-keyword >in</span> [:sin, :cos, :tan, :exp, :log, :log2, :log10, :sqrt, :inv]
    eval(<span class=hljs-keyword >quote</span>
        <span class=hljs-comment ># this is a line of code generated using string interpolation</span>
        Base.$f(m::Measurement) = $f(m.x) ± abs(ForwardDiff.derivative($f, m.x) * m.σ)
    <span class=hljs-keyword >end</span>)
<span class=hljs-keyword >end</span></code></pre>
<pre><code class="julia hljs">cos(m)</code></pre>
<pre><code class="julia hljs">-<span class=hljs-number >0.9111302618846769</span> ± <span class=hljs-number >0.12363554557252697</span></code></pre>
<pre><code class="julia hljs">log(m^<span class=hljs-number >2</span>)</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >4.394449154672439</span> ± <span class=hljs-number >0.06666666666666665</span></code></pre>
<pre><code class="julia hljs"><span class=hljs-number >2</span>log(m)  <span class=hljs-comment ># same</span></code></pre>
<pre><code class="julia hljs"><span class=hljs-number >4.394449154672439</span> ± <span class=hljs-number >0.06666666666666667</span></code></pre>
<p>Let&#39;s apply this to in a somewhat realistic setting. Many methods in analytical chemistry are based on the law of <a href="https://en.wikipedia.org/wiki/Beer&#37;E2&#37;80&#37;93Lambert_law">Beer-Lambert</a>. This law relates the absorption of a ray of light passing through a cuvet with the concentration of a solution. For a given reference intensity <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">I_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> at concentration of 0 and a lower intensity <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> when it passes through a solution of concentration <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span>, we have</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>log</mi><mo>⁡</mo><mrow><mo fence=true >(</mo><mfrac><msub><mi>I</mi><mn>0</mn></msub><mi>I</mi></mfrac><mo fence=true >)</mo></mrow><mo>=</mo><mi>ε</mi><mi>c</mi><mi>l</mi><mtext> </mtext><mo separator=true >,</mo></mrow><annotation encoding="application/x-tex">
\log \left(\frac{I_0}{I}\right) = \varepsilon c l\,,
</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:2.40003em;vertical-align:-0.95003em;"></span><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=minner ><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.36033em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ε</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mpunct >,</span></span></span></span></span>
<p>with <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ε</span></span></span></span> the molar extinction coefficient and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> the thickness of the cuvet.</p>
<p>Suppose we want to determine the extinction coefficient for some substance, using a cuvet of thickness <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.02</mn><mo>±</mo><mn>0.001</mn></mrow><annotation encoding="application/x-tex">0.02\pm 0.001</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.72777em;vertical-align:-0.08333em;"></span><span class=mord >0</span><span class=mord >.</span><span class=mord >0</span><span class=mord >2</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >±</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span><span class=mord >.</span><span class=mord >0</span><span class=mord >0</span><span class=mord >1</span></span></span></span> and a reference solution of a concentration of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.73</mn><mo>±</mo><mn>0.02</mn></mrow><annotation encoding="application/x-tex">0.73\pm 0.02</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.72777em;vertical-align:-0.08333em;"></span><span class=mord >0</span><span class=mord >.</span><span class=mord >7</span><span class=mord >3</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >±</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span><span class=mord >.</span><span class=mord >0</span><span class=mord >2</span></span></span></span> M.</p>
<pre><code class="julia hljs">c = <span class=hljs-number >0.72</span> ± <span class=hljs-number >0.02</span>
l = <span class=hljs-number >0.02</span> ± <span class=hljs-number >1e-4</span></code></pre>
<pre><code class="julia hljs"><span class=hljs-number >0.02</span> ± <span class=hljs-number >0.0001</span></code></pre>
<p>We perform some intensity measurements, with associated measurement errors.</p>
<pre><code class="julia hljs">I0 = [<span class=hljs-number >0.8</span> ± <span class=hljs-number >0.07</span>, <span class=hljs-number >1.1</span> ± <span class=hljs-number >0.11</span>, <span class=hljs-number >1.2</span> ± <span class=hljs-number >0.08</span>]
I1 = [<span class=hljs-number >0.2</span> ± <span class=hljs-number >0.12</span>, <span class=hljs-number >0.3</span> ± <span class=hljs-number >0.08</span>, <span class=hljs-number >0.2</span> ± <span class=hljs-number >0.3</span>]</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >3</span>-element <span class=hljs-built_in >Array</span>{Measurement,<span class=hljs-number >1</span>}:
     <span class=hljs-number >0.2</span> ± <span class=hljs-number >0.12</span>
     <span class=hljs-number >0.3</span> ± <span class=hljs-number >0.08</span>
     <span class=hljs-number >0.2</span> ± <span class=hljs-number >0.3</span></code></pre>
<p>Some straightforward manipulations of the Beer-Lambert formula allows us to compute an estimate of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ε</span></span></span></span>. Since the estimator only uses operations which allow the uncertainty propagation, the estimate directly gives the value with the standard error.</p>
<pre><code class="julia hljs">mean(x) = sum(x) / length(x)
ε = log(mean(I0) * inv(mean(I1))) * inv(c) * inv(l)</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >103.33868440484952</span> ± <span class=hljs-number >33.327646598494475</span></code></pre>
<p>We can then subsequently use this molecular extinction in further computations, for example to estimate new concentrations, directly with confidence intervals&#33;</p>
<h2 id=general_n-dimensional_convolutions ><a href="#general_n-dimensional_convolutions" class=header-anchor >General <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>-dimensional convolutions</a></h2>
<p>The flexibility of Julia makes it easy to write general, but highly optimized code. One aspect, I really like is its indexing system. When you get the hang of it, you will never complain again about the 1-based indexing&#33;</p>
<p>Consider an array:</p>
<pre><code class="julia hljs">A = rand(<span class=hljs-number >3</span>, <span class=hljs-number >5</span>)</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >3</span>×<span class=hljs-number >5</span> <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>,<span class=hljs-number >2</span>}:
     <span class=hljs-number >0.270625</span>  <span class=hljs-number >0.397293</span>  <span class=hljs-number >0.348364</span>   <span class=hljs-number >0.241978</span>   <span class=hljs-number >0.424326</span>
     <span class=hljs-number >0.850476</span>  <span class=hljs-number >0.213356</span>  <span class=hljs-number >0.609399</span>   <span class=hljs-number >0.0948646</span>  <span class=hljs-number >0.665579</span>
     <span class=hljs-number >0.789739</span>  <span class=hljs-number >0.435704</span>  <span class=hljs-number >0.0511797</span>  <span class=hljs-number >0.211703</span>   <span class=hljs-number >0.586431</span></code></pre>
<p>Julia&#39;s arrays are column major, rather than row major as in Numpy. This means that you should see a matrix as a set of columns, not a set of rows. This is important, when processing matrices, as processing matrices row by row can be substantially slower than processing them column by column.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> BenchmarkTools

<span class=hljs-keyword >function</span> sum_row_by_row(A)
    result = <span class=hljs-number >0.0</span>
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:size(A, <span class=hljs-number >1</span>)
        <span class=hljs-keyword >for</span> j <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:size(A, <span class=hljs-number >2</span>)
            result += A[i,j]
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> result
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> sum_col_by_col(A)
    result = <span class=hljs-number >0.0</span>
    <span class=hljs-keyword >for</span> j <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:size(A, <span class=hljs-number >2</span>)
        <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:size(A, <span class=hljs-number >1</span>)
            result += A[i,j]
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> result
<span class=hljs-keyword >end</span>

B = randn(<span class=hljs-number >5000</span>, <span class=hljs-number >5000</span>);  <span class=hljs-comment ># bigger matrix to illustrate</span></code></pre>
<pre><code class="julia hljs"><span class=hljs-meta >@btime</span> sum_row_by_row($B)</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >164.997</span> ms (<span class=hljs-number >0</span> allocations: <span class=hljs-number >0</span> bytes)





    <span class=hljs-number >6479.463039431909</span></code></pre>
<pre><code class="julia hljs"><span class=hljs-meta >@btime</span> sum_col_by_col($B)</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >27.304</span> ms (<span class=hljs-number >0</span> allocations: <span class=hljs-number >0</span> bytes)





    <span class=hljs-number >6479.463039430924</span></code></pre>
<p>Not a bad speedup by just switching the order of the two loops&#33; The order of the elements can be accessed using <code>LinearIndices&#40;A&#41;</code>. This will generate a matrix of the same size of <code>A</code>, containing the index of all elements.</p>
<pre><code class="julia hljs"><span class=hljs-built_in >LinearIndices</span>(A)</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >3</span>×<span class=hljs-number >5</span> <span class=hljs-built_in >LinearIndices</span>{<span class=hljs-number >2</span>,<span class=hljs-built_in >Tuple</span>{Base.OneTo{<span class=hljs-built_in >Int64</span>},Base.OneTo{<span class=hljs-built_in >Int64</span>}}}:
     <span class=hljs-number >1</span>  <span class=hljs-number >4</span>  <span class=hljs-number >7</span>  <span class=hljs-number >10</span>  <span class=hljs-number >13</span>
     <span class=hljs-number >2</span>  <span class=hljs-number >5</span>  <span class=hljs-number >8</span>  <span class=hljs-number >11</span>  <span class=hljs-number >14</span>
     <span class=hljs-number >3</span>  <span class=hljs-number >6</span>  <span class=hljs-number >9</span>  <span class=hljs-number >12</span>  <span class=hljs-number >15</span></code></pre>
<p>When indexing over an array, such an object can be generated and used to process the array. It seems incredible wasteful, but upon compiling the function this is completely optimized away, so it has no memory footprint&#33;</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> sum_lin_ind(A)
    L = <span class=hljs-built_in >LinearIndices</span>(A)
    result = <span class=hljs-number >0.0</span>
    <span class=hljs-keyword >for</span> I <span class=hljs-keyword >in</span> L
        result += A[I]
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> result
<span class=hljs-keyword >end</span>

<span class=hljs-meta >@btime</span> sum_lin_ind($B)</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >27.468</span> ms (<span class=hljs-number >0</span> allocations: <span class=hljs-number >0</span> bytes)





    <span class=hljs-number >6479.463039430924</span></code></pre>
<p>In many cases, <code>CartesianIndices&#40;A&#41;</code> is more useful, this will generate an array of the same size, but containing the <code>CartesianIndex</code> instances. These hold the indices of the corresponding elements and are in general easier to work with.</p>
<pre><code class="julia hljs"><span class=hljs-built_in >CartesianIndices</span>(A)</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >3</span>×<span class=hljs-number >5</span> <span class=hljs-built_in >CartesianIndices</span>{<span class=hljs-number >2</span>,<span class=hljs-built_in >Tuple</span>{Base.OneTo{<span class=hljs-built_in >Int64</span>},Base.OneTo{<span class=hljs-built_in >Int64</span>}}}:
     <span class=hljs-built_in >CartesianIndex</span>(<span class=hljs-number >1</span>, <span class=hljs-number >1</span>)  <span class=hljs-built_in >CartesianIndex</span>(<span class=hljs-number >1</span>, <span class=hljs-number >2</span>)  …  <span class=hljs-built_in >CartesianIndex</span>(<span class=hljs-number >1</span>, <span class=hljs-number >5</span>)
     <span class=hljs-built_in >CartesianIndex</span>(<span class=hljs-number >2</span>, <span class=hljs-number >1</span>)  <span class=hljs-built_in >CartesianIndex</span>(<span class=hljs-number >2</span>, <span class=hljs-number >2</span>)     <span class=hljs-built_in >CartesianIndex</span>(<span class=hljs-number >2</span>, <span class=hljs-number >5</span>)
     <span class=hljs-built_in >CartesianIndex</span>(<span class=hljs-number >3</span>, <span class=hljs-number >1</span>)  <span class=hljs-built_in >CartesianIndex</span>(<span class=hljs-number >3</span>, <span class=hljs-number >2</span>)     <span class=hljs-built_in >CartesianIndex</span>(<span class=hljs-number >3</span>, <span class=hljs-number >5</span>)</code></pre>
<p>The important thing the note is that this all works agnostic on the dimensionality of the arrays. Whether <code>A</code> has one, two, three of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> dimensions, it all works the same.</p>
<p>I will illustrate this by writing a small piece of code for performing a general convolution, regardless of the dimensionality of <code>A</code>. With minor modifications, this can be a versatile building block for many interesting numerical algorithms.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> generalconvolve!(A::<span class=hljs-built_in >AbstractArray</span>, out, W, f=(v,a)-&gt;v)
    <span class=hljs-meta >@assert</span> size(A) == size(out)
    <span class=hljs-meta >@assert</span> all(size(W) .% <span class=hljs-number >2</span> .== <span class=hljs-number >1</span>)  <span class=hljs-comment ># all dimensions of W odd</span>
    C = <span class=hljs-built_in >CartesianIndices</span>(A)
    Ifirst, Ilast = first(C), last(C)
    I1 = oneunit(Ifirst)
    width = <span class=hljs-built_in >CartesianIndices</span>(W)[div(length(W)+<span class=hljs-number >1</span>, <span class=hljs-number >2</span>)] - I1
    <span class=hljs-keyword >for</span> I <span class=hljs-keyword >in</span> (Ifirst+width):(Ilast-width)
        value = <span class=hljs-number >0.0</span>
        <span class=hljs-keyword >for</span> (J, w) <span class=hljs-keyword >in</span> zip((I-width):(I+width), W)
            value += w * A[J]
        <span class=hljs-keyword >end</span>
        out[I] = f(value, A[I])
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> out
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> generalconvolve(A::<span class=hljs-built_in >AbstractArray</span>, W, f=(v,a)-&gt;v)
    out = copy(A)
    <span class=hljs-keyword >return</span> generalconvolve!(A, out, W, f)
<span class=hljs-keyword >end</span></code></pre>
<p>This function has as inputs:</p>
<ul>
<li><p><code>A</code>: a general array;</p>

<li><p><code>W</code>: a smaller array with the same number of dimensions to do the convolution;</p>

<li><p><code>f</code>: a function to transform the convolved values, with the convolution result and the original value as input. The identity map is the result, but this can be used for more complex methods.</p>

</ul>
<h3 id=kernel_smoothing ><a href="#kernel_smoothing" class=header-anchor >Kernel smoothing</a></h3>
<p>Let us start with a basic example from statistics: <a href="https://en.wikipedia.org/wiki/Kernel_smoother">kernel smoothing</a>. In the most simple case, we have some noisy vector <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=bold >x</mi></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.44444em;vertical-align:0em;"></span><span class=mord ><span class="mord mathbf">x</span></span></span></span></span> and we want to denoise it by taking a moving window average: the value at every point is replaced by a local average. Given a bandwidth of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span> &#40;taking the average of the elements <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mi>p</mi></mrow></msub><mo separator=true >,</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator=true >,</mo><mo>…</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator=true >,</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator=true >,</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator=true >,</mo><mo>…</mo><mo separator=true >,</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mi>p</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator=true >,</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>+</mo><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-p}, x_{i-p+1},\ldots x_{i-1}, x_{i}, x_{i+1},\ldots, x_{i+p-1}, x_{i+p}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.716668em;vertical-align:-0.286108em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=minner >…</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.208331em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.208331em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=minner >…</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> for at every position <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span>&#41; is done by setting an appropriate value of <code>W</code>.</p>
<pre><code class="julia hljs">kernelsmoothing(x::<span class=hljs-built_in >AbstractVector</span>; p::<span class=hljs-built_in >Int</span>=<span class=hljs-number >3</span>) = generalconvolve(x, ones(<span class=hljs-number >2</span>p+<span class=hljs-number >1</span>) / (<span class=hljs-number >2</span>p+<span class=hljs-number >1</span>));</code></pre>
<pre><code class="julia hljs"><span class=hljs-comment ># generate a noisy signal</span>
t = <span class=hljs-number >0</span>:<span class=hljs-number >0.01</span>:<span class=hljs-number >3</span>
x = exp.(t) .* sin.(t) + randn(length(t));</code></pre>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Plots

plot(t, x, label=<span class=hljs-string >&quot;signal&quot;</span>)
plot!(t, kernelsmoothing(x, p=<span class=hljs-number >10</span>), label=<span class=hljs-string >&quot;smoothed signal&quot;</span>)
xlabel!(<span class=hljs-string >&quot;t&quot;</span>)</code></pre>
<p><img src="/images/2019_julia/output_51_0.png" alt=plot  /></p>
<p>Of course, other kernels can be used just as easily, as long as <code>W</code> is a proper probability density function. This way, a decayed importance can be placed on values farther from the center.</p>
<h3 id=image_gradients ><a href="#image_gradients" class=header-anchor >Image gradients</a></h3>
<p>Moving to two dimensions we can implement some basic image processing&#33; To compute the gradient of an image &#40;i.e. how the pixel values change locally in the <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> or <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> direction we just use the correct convolution.</p>
<pre><code class="julia hljs">image_grad_x(image::<span class=hljs-built_in >Matrix</span>) = generalconvolve(image, [-<span class=hljs-number >1</span> <span class=hljs-number >0</span> <span class=hljs-number >1</span>; -<span class=hljs-number >1</span> <span class=hljs-number >0</span> <span class=hljs-number >1</span>; -<span class=hljs-number >1</span> <span class=hljs-number >0</span> <span class=hljs-number >1</span>] / <span class=hljs-number >6</span>)[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>,<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>];
image_grad_y(image::<span class=hljs-built_in >Matrix</span>) = generalconvolve(image, [-<span class=hljs-number >1</span> -<span class=hljs-number >1</span> -<span class=hljs-number >1</span>; <span class=hljs-number >0</span> <span class=hljs-number >0</span> <span class=hljs-number >0</span>; <span class=hljs-number >1</span> <span class=hljs-number >1</span> <span class=hljs-number >1</span>] / <span class=hljs-number >6</span>)[<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>,<span class=hljs-number >2</span>:<span class=hljs-keyword >end</span>-<span class=hljs-number >1</span>];</code></pre>
<pre><code class="julia hljs">A = reshape([<span class=hljs-number >2.5</span>x - <span class=hljs-number >0.1</span>y^<span class=hljs-number >2</span> + <span class=hljs-number >2</span>*x*y <span class=hljs-keyword >for</span> x <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >7</span> <span class=hljs-keyword >for</span> y <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10</span>], <span class=hljs-number >10</span>, <span class=hljs-number >7</span>)</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >10</span>×<span class=hljs-number >7</span> <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>,<span class=hljs-number >2</span>}:
      <span class=hljs-number >4.4</span>   <span class=hljs-number >8.9</span>  <span class=hljs-number >13.4</span>  <span class=hljs-number >17.9</span>   <span class=hljs-number >22.4</span>   <span class=hljs-number >26.9</span>   <span class=hljs-number >31.4</span>
      <span class=hljs-number >6.1</span>  <span class=hljs-number >12.6</span>  <span class=hljs-number >19.1</span>  <span class=hljs-number >25.6</span>   <span class=hljs-number >32.1</span>   <span class=hljs-number >38.6</span>   <span class=hljs-number >45.1</span>
      <span class=hljs-number >7.6</span>  <span class=hljs-number >16.1</span>  <span class=hljs-number >24.6</span>  <span class=hljs-number >33.1</span>   <span class=hljs-number >41.6</span>   <span class=hljs-number >50.1</span>   <span class=hljs-number >58.6</span>
      <span class=hljs-number >8.9</span>  <span class=hljs-number >19.4</span>  <span class=hljs-number >29.9</span>  <span class=hljs-number >40.4</span>   <span class=hljs-number >50.9</span>   <span class=hljs-number >61.4</span>   <span class=hljs-number >71.9</span>
     <span class=hljs-number >10.0</span>  <span class=hljs-number >22.5</span>  <span class=hljs-number >35.0</span>  <span class=hljs-number >47.5</span>   <span class=hljs-number >60.0</span>   <span class=hljs-number >72.5</span>   <span class=hljs-number >85.0</span>
     <span class=hljs-number >10.9</span>  <span class=hljs-number >25.4</span>  <span class=hljs-number >39.9</span>  <span class=hljs-number >54.4</span>   <span class=hljs-number >68.9</span>   <span class=hljs-number >83.4</span>   <span class=hljs-number >97.9</span>
     <span class=hljs-number >11.6</span>  <span class=hljs-number >28.1</span>  <span class=hljs-number >44.6</span>  <span class=hljs-number >61.1</span>   <span class=hljs-number >77.6</span>   <span class=hljs-number >94.1</span>  <span class=hljs-number >110.6</span>
     <span class=hljs-number >12.1</span>  <span class=hljs-number >30.6</span>  <span class=hljs-number >49.1</span>  <span class=hljs-number >67.6</span>   <span class=hljs-number >86.1</span>  <span class=hljs-number >104.6</span>  <span class=hljs-number >123.1</span>
     <span class=hljs-number >12.4</span>  <span class=hljs-number >32.9</span>  <span class=hljs-number >53.4</span>  <span class=hljs-number >73.9</span>   <span class=hljs-number >94.4</span>  <span class=hljs-number >114.9</span>  <span class=hljs-number >135.4</span>
     <span class=hljs-number >12.5</span>  <span class=hljs-number >35.0</span>  <span class=hljs-number >57.5</span>  <span class=hljs-number >80.0</span>  <span class=hljs-number >102.5</span>  <span class=hljs-number >125.0</span>  <span class=hljs-number >147.</span></code></pre>
<pre><code class="julia hljs">heatmap(A)</code></pre>
<p><img src="/images/2019_julia/output_56_0.png" alt=plot  /></p>
<pre><code class="julia hljs">Ax = image_grad_x(A)</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >8</span>×<span class=hljs-number >5</span> <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>,<span class=hljs-number >2</span>}:
      <span class=hljs-number >6.5</span>   <span class=hljs-number >6.5</span>   <span class=hljs-number >6.5</span>   <span class=hljs-number >6.5</span>   <span class=hljs-number >6.5</span>
      <span class=hljs-number >8.5</span>   <span class=hljs-number >8.5</span>   <span class=hljs-number >8.5</span>   <span class=hljs-number >8.5</span>   <span class=hljs-number >8.5</span>
     <span class=hljs-number >10.5</span>  <span class=hljs-number >10.5</span>  <span class=hljs-number >10.5</span>  <span class=hljs-number >10.5</span>  <span class=hljs-number >10.5</span>
     <span class=hljs-number >12.5</span>  <span class=hljs-number >12.5</span>  <span class=hljs-number >12.5</span>  <span class=hljs-number >12.5</span>  <span class=hljs-number >12.5</span>
     <span class=hljs-number >14.5</span>  <span class=hljs-number >14.5</span>  <span class=hljs-number >14.5</span>  <span class=hljs-number >14.5</span>  <span class=hljs-number >14.5</span>
     <span class=hljs-number >16.5</span>  <span class=hljs-number >16.5</span>  <span class=hljs-number >16.5</span>  <span class=hljs-number >16.5</span>  <span class=hljs-number >16.5</span>
     <span class=hljs-number >18.5</span>  <span class=hljs-number >18.5</span>  <span class=hljs-number >18.5</span>  <span class=hljs-number >18.5</span>  <span class=hljs-number >18.5</span>
     <span class=hljs-number >20.5</span>  <span class=hljs-number >20.5</span>  <span class=hljs-number >20.5</span>  <span class=hljs-number >20.5</span>  <span class=hljs-number >20</span></code></pre>
<pre><code class="julia hljs">heatmap(Ax)</code></pre>
<p><img src="/images/2019_julia/output_58_0.png" alt=plot  /></p>
<pre><code class="julia hljs">Ay = image_grad_y(A)</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >8</span>×<span class=hljs-number >5</span> <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>,<span class=hljs-number >2</span>}:
     <span class=hljs-number >3.6</span>  <span class=hljs-number >5.6</span>  <span class=hljs-number >7.6</span>  <span class=hljs-number >9.6</span>  <span class=hljs-number >11.6</span>
     <span class=hljs-number >3.4</span>  <span class=hljs-number >5.4</span>  <span class=hljs-number >7.4</span>  <span class=hljs-number >9.4</span>  <span class=hljs-number >11.4</span>
     <span class=hljs-number >3.2</span>  <span class=hljs-number >5.2</span>  <span class=hljs-number >7.2</span>  <span class=hljs-number >9.2</span>  <span class=hljs-number >11.2</span>
     <span class=hljs-number >3.0</span>  <span class=hljs-number >5.0</span>  <span class=hljs-number >7.0</span>  <span class=hljs-number >9.0</span>  <span class=hljs-number >11.0</span>
     <span class=hljs-number >2.8</span>  <span class=hljs-number >4.8</span>  <span class=hljs-number >6.8</span>  <span class=hljs-number >8.8</span>  <span class=hljs-number >10.8</span>
     <span class=hljs-number >2.6</span>  <span class=hljs-number >4.6</span>  <span class=hljs-number >6.6</span>  <span class=hljs-number >8.6</span>  <span class=hljs-number >10.6</span>
     <span class=hljs-number >2.4</span>  <span class=hljs-number >4.4</span>  <span class=hljs-number >6.4</span>  <span class=hljs-number >8.4</span>  <span class=hljs-number >10.4</span>
     <span class=hljs-number >2.2</span>  <span class=hljs-number >4.2</span>  <span class=hljs-number >6.2</span>  <span class=hljs-number >8.2</span>  <span class=hljs-number >10.2</span></code></pre>
<pre><code class="julia hljs">heatmap(Ay)</code></pre>
<p><img src="/images/2019_julia/output_60_0.png" alt=plot  /></p>
<p>We can directly apply this a real image, and it works&#33;</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> TestImages

img = convert(<span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}, testimage(<span class=hljs-string >&quot;cameraman&quot;</span>))[<span class=hljs-keyword >end</span>:-<span class=hljs-number >1</span>:<span class=hljs-number >1</span>,:]
heatmap(img)</code></pre>
<p><img src="/images/2019_julia/output_62_0.png" alt=plot  /></p>
<pre><code class="julia hljs">heatmap(image_grad_x(img))</code></pre>
<p><img src="/images/2019_julia/output_63_0.png" alt=plot  /></p>
<pre><code class="julia hljs">heatmap(image_grad_y(img))</code></pre>
<p><img src="/images/2019_julia/output_64_0.png" alt=plot  /></p>
<h3 id=game_of_life_a_cellular_automaton ><a href="#game_of_life_a_cellular_automaton" class=header-anchor >Game of Life: a cellular automaton</a></h3>
<p>Something different, our piece of code can be hacked to perform the update for <a href="https://en.wikipedia.org/wiki/Conway&#37;27s_Game_of_Life">Conway&#39;s Game of Life</a>. This is a simple cellular automata defined on a 2-D grid with binary states, a cell can either be alive or dead. The rules for updating a cell&#39;s state from one step to the next follows the following simple rules:</p>
<ul>
<li><p>a living cell with one or two living neighbors dies &#40;underpopulation&#41;;</p>

<li><p>a living cell with four or more living neighbors dies &#40;overpopulation&#41;;</p>

<li><p>a living cell with two or three living neighbors remains alive &#40;survival&#41;;</p>

<li><p>a dead cell with exactly three living neighbors turns alive &#40;procreation&#41;.</p>

</ul>
<p>We choose <code>W</code> such that the living neighbors are counted. <code>f</code> is chosen to represent the above updating rules.</p>
<pre><code class="julia hljs">gol_rules(nneighbors, state) = (state &amp;&amp; <span class=hljs-number >2</span> &lt;= nneighbors &lt;= <span class=hljs-number >3</span>) || (!state &amp;&amp; nneighbors == <span class=hljs-number >3</span>);
gol_update(A::<span class=hljs-built_in >AbstractMatrix</span>{<span class=hljs-built_in >Bool</span>}) = generalconvolve(A, [<span class=hljs-number >1</span> <span class=hljs-number >1</span> <span class=hljs-number >1</span>; <span class=hljs-number >1</span> <span class=hljs-number >0</span> <span class=hljs-number >1</span>; <span class=hljs-number >1</span> <span class=hljs-number >1</span> <span class=hljs-number >1</span>], gol_rules);</code></pre>
<pre><code class="julia hljs">A = rand(<span class=hljs-built_in >Bool</span>, <span class=hljs-number >100</span>, <span class=hljs-number >100</span>);
heatmap(A)</code></pre>
<p><img src="/images/2019_julia/output_67_0.png" alt=plot  /></p>
<pre><code class="julia hljs"><span class=hljs-meta >@btime</span> A = gol_update($A)  <span class=hljs-comment ># quite fast!</span>
heatmap(A)</code></pre>
<pre><code class="julia hljs"><span class=hljs-number >220.606</span> μs (<span class=hljs-number >2</span> allocations: <span class=hljs-number >10.09</span> KiB)</code></pre>
<p><img src="/images/2019_julia/output_68_1.png" alt=plot  /></p>
<p>Simulate 1000 time steps.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >1000</span>
    A = gol_update(A)
<span class=hljs-keyword >end</span>
heatmap(A)</code></pre>
<p><img src="/images/2019_julia/output_70_0.png" alt=plot  /></p>
<p>We see that all the random states have been replaced by simple stationary structures and oscillators. Note that the edges are not updated because no correct boundary conditions are implemented.</p>
<h3 id=diffusion_of_ink_in_3d ><a href="#diffusion_of_ink_in_3d" class=header-anchor >Diffusion of ink in 3D</a></h3>
<p>As an example in 3D, consider a volume containing some spots of ink. Using a Gaussian convolution, we can simulate how these drops have diffused after some time.</p>
<p>First, we generate a matrix with ink drops at random places.</p>
<pre><code class="julia hljs">A = zeros(<span class=hljs-number >100</span>, <span class=hljs-number >100</span>, <span class=hljs-number >100</span>)
A[rand(<span class=hljs-built_in >CartesianIndices</span>(A), <span class=hljs-number >20</span>)] .= <span class=hljs-number >10.0</span>;  <span class=hljs-comment ># 20 drops of ink at random spots</span></code></pre>
<p>The diffusion rate is determined by <a href="https://en.wikipedia.org/wiki/Fick&#37;27s_laws_of_diffusion">Fick&#39;s law</a>, for the sake of simplicity, we will simulate this using a simple Gaussian convolution in three dimensions.</p>
<pre><code class="julia hljs">W = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, <span class=hljs-number >5</span>, <span class=hljs-number >5</span>, <span class=hljs-number >5</span>)

<span class=hljs-keyword >for</span> I <span class=hljs-keyword >in</span> <span class=hljs-built_in >CartesianIndices</span>(W)
    i, j, k = <span class=hljs-built_in >Tuple</span>(I)
    W[i,j,k] = exp(-(i-<span class=hljs-number >3</span>)^<span class=hljs-number >2</span> - (j-<span class=hljs-number >3</span>)^<span class=hljs-number >2</span> - (k-<span class=hljs-number >3</span>)^<span class=hljs-number >2</span>)
<span class=hljs-keyword >end</span>

<span class=hljs-comment ># normalize</span>
W ./= sum(W);</code></pre>
<pre><code class="julia hljs">nsteps = <span class=hljs-number >50</span>
Anew = similar(A)

<span class=hljs-keyword >for</span> step <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:nsteps
    generalconvolve!(A, Anew, W)
    A, Anew = Anew, A
<span class=hljs-keyword >end</span></code></pre>
<p>By taking a slice, we can see how the ink has spread.</p>
<pre><code class="julia hljs">heatmap(A[<span class=hljs-number >31</span>, :, :])</code></pre>
<p><img src="/images/2019_julia/output_78_0.png" alt=plot  /></p>
<h3 id=piecing_it_together_convoluton_with_uncertainty ><a href="#piecing_it_together_convoluton_with_uncertainty" class=header-anchor >Piecing it together: convoluton with uncertainty</a></h3>
<p>We developed a structure for dealing with a uncertainty propagation and a general convolution function. Can these two seemingly unrelated concepts play together? Without any problem&#33;</p>
<p>Consider a noise 1-D signal, with an uncertainty proportional to the absolute value of the signal. We first want to do a simple convolution similar to the kernel smoothing of earlier. Finally, we pass the signal to a sigmoid function, such that it is squeezed into the <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mn>0</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span> interval.</p>
<pre><code class="julia hljs">z = <span class=hljs-number >8</span>exp.(-<span class=hljs-number >0.4</span>t).*sin.(<span class=hljs-number >2</span>t)
z = z .+ <span class=hljs-number >0.1</span>randn(length(t)) .± (<span class=hljs-number >0.2</span>abs.(z).+ <span class=hljs-number >0.1</span>);</code></pre>
<pre><code class="julia hljs">plot(val.(z), color=<span class=hljs-string >&quot;blue&quot;</span>, label=<span class=hljs-string >&quot;z&quot;</span>)
plot!(val.(z) + <span class=hljs-number >2</span>err.(z), color=<span class=hljs-string >&quot;red&quot;</span>, label=<span class=hljs-string >&quot;upper bound&quot;</span>)
plot!(val.(z) - <span class=hljs-number >2</span>err.(z), color=<span class=hljs-string >&quot;red&quot;</span>, label=<span class=hljs-string >&quot;lower bound&quot;</span>)</code></pre>
<p><img src="/images/2019_julia/output_81_0.png" alt=plot  /></p>
<pre><code class="julia hljs">sigmoid(x, a=<span class=hljs-number >0.0</span>) = inv(exp(-x) + <span class=hljs-number >1.0</span>);</code></pre>
<pre><code class="julia hljs">conv_sofmax_signal(z::<span class=hljs-built_in >Vector</span>; p::<span class=hljs-built_in >Int</span>=<span class=hljs-number >5</span>) = generalconvolve(z, ones(<span class=hljs-number >2</span>p+<span class=hljs-number >1</span>)/(<span class=hljs-number >2</span>p+<span class=hljs-number >1</span>), (x,a)-&gt;inv(exp(-<span class=hljs-number >1</span>x) + <span class=hljs-number >1.0</span>))[p+<span class=hljs-number >1</span>:<span class=hljs-keyword >end</span>-p-<span class=hljs-number >1</span>];</code></pre>
<pre><code class="julia hljs">p = conv_sofmax_signal(z);
plot(val.(p), color=<span class=hljs-string >&quot;blue&quot;</span>, label=<span class=hljs-string >&quot;processed signal&quot;</span>)
plot!(val.(p)+<span class=hljs-number >2</span>err.(p), color=<span class=hljs-string >&quot;red&quot;</span>, label=<span class=hljs-string >&quot;upper bound&quot;</span>)
plot!(val.(p)-<span class=hljs-number >2</span>err.(p), color=<span class=hljs-string >&quot;red&quot;</span>, label=<span class=hljs-string >&quot;lower bound&quot;</span>)</code></pre>
<p><img src="/images/2019_julia/output_84_0.png" alt=plot  /></p>
<p>We see that the noise has been filtered and the error has been processed appropriately. Note that the region where the signal is 1, the uncertainty is really low. This corresponds to one of the flat regions of the sigmoid. When the value of <code>z</code> is large, the output is close to one, irregardless of noise.</p>
<p>Admittedly, this example seems a bit contrived. However, when you think of <code>z</code> as the output of some neural network, this might make some more sense, especially if you image performing binary classification on some space. For example, detecting vegetation in remote sensing data. The methodology that we have developed is not that far from a Bayesian artificial neural network.</p>
<p>The elephant in the room here is that by doing this convolution, the measurements are no longer independent, which leads to a serious underestimation of the uncertainty&#33; Implementing measurements which also keep track of their underlying correlations is left as an exercise for the reader.</p>
<div class=page-foot >
  <div class=copyright >
    &copy; Michiel Stock. Last modified: June 05, 2025. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
        </div> 
    </div>